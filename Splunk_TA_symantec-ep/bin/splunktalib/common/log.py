"""
Copyright (C) 2005-2015 Splunk Inc. All Rights Reserved.

log utility for TA
"""

import logging
import logging.handlers
from splunktalib.splunk_platform import make_splunkhome_path

from splunktalib.common.pattern import singleton


def log_enter_exit(logger):
    """
    Log decorator to log function enter and exit
    """
    def log_decorator(func):
        def wrapper(*args, **kwargs):
            logger.debug("{} entered.".format(func.__name__))
            result = func(*args, **kwargs)
            logger.debug("{} exited.".format(func.__name__))
            return result
        return wrapper
    return log_decorator


@singleton
class Logs(object):

    def __init__(self):
        self._loggers = {}

    def get_logger(self, name, level=logging.WARNING,
                   maxBytes=25000000, backupCount=5):
        """
        Set up a default logger.

        :param name: The log file name.
        :param level: The logging level.
        :param maxBytes: The maximum log file size before rollover.
        :param backupCount: The number of log files to retain.
        """

        # Strip ".py" from the log file name if auto-generated by a script.
        if '.py' in name:
            name = name.replace(".py", "")

        if name in self._loggers.keys():
            return self._loggers[name]

        logfile = make_splunkhome_path(["var", "log", "splunk", name + '.log'])

        logger = logging.getLogger(name)
        # Prevent the log messages from being duplicated in the python.log file
        logger.propagate = False
        logger.level = level

        # Prevent re-adding handlers to the logger object,
        # which can cause duplicate log lines.
        handler_exists = any(
            [True for h in logger.handlers if h.baseFilename == logfile])
        if not handler_exists:
            file_handler = logging.handlers.RotatingFileHandler(
                logfile, mode='a', maxBytes=maxBytes, backupCount=backupCount)
            formatter = logging.Formatter(
                "%(asctime)s %(levelname)s pid=%(process)d tid=%(threadName)s "
                "file=%(filename)s:%(funcName)s:%(lineno)d | %(message)s")
            file_handler.setFormatter(formatter)
            logger.addHandler(file_handler)

        self._loggers[name] = logger

        return logger

    def set_level(self, level, name=None):
        """
        Change the log level of the logging

        :param level: the level of the logging to be setLevel
        :param name: the name of the logging to set, in case it is not set,
                     all the loggers will be affected
        """

        if name is not None:
            logger = self._loggers.get(name)
            if logger is not None:
                logger.setLevel(level)
        else:
            for logger in self._loggers.values():
                logger.setLevel(level)
